# KV Flows Knowledge Transfer Guide

• **KV Database System**: Explains the Key-Value temporary database created to handle high traffic from large merchants (like IRCTC), which stores data for 12 hours before flushing to regular SQL database, supporting standard CRUD operations with fallback mechanisms.

• **KV Configuration & Management**: Covers service configurations including KVC merchant cutover (merchant enablement), KVC enabled tables (specific table routing), KV hard killing merchants (direct SQL routing), and recaching capabilities for data persistence across sessions.

• **IMC & Testing Framework**: Details In-Memory Cache (IMC) for dashboard tables to reduce Redis/SQL lookups, testing methodologies using source/action logs (KV, SQL, KV&SQL), troubleshooting drainer issues, and verification of data flow through different database layers.

---

It's going to get sort of it has to be visible right in the Okay. I mean, ask is joining.
That's right.
Okay guys, I'll tell from a QA perspective like what is KV and how do we test KV so that for your own repos you guys can test how to test KV and everything is working fine or not for all the flows. So don't think it is like a very different topic you know what database is right a basic SQL database KV is very similar to SQL. Okay. Why we have created KV is like we have onboarded a very huge merchants like IRCTC just IRCTC and other merchants. So they'll have a huge traffic for the for them. So to handle those traffic our SQL we found that we doesn't have that much capacity to handle that traffic. So what we did is like we created a temporary database called KV so that First it will come to KV and it will fall back to RDB. This is what KV is. This is why we have created KVs. So it is to
it will fall back to DB a database our database. So first whatever the data comes it will comes first to KV and it will fall back to DB. So that to reduce the complexity to reduce the uh datas everything because KV is like how they have uh uh designed is like KV is similar to key value. Okay. Key value database. So they'll be storing datas in the form of primary keys and secondary keys. Primary key you know right it's like the uniquely identifying of one data secondary key is like for that primary key we'll have many secondary keys. So that is how KV is designed. So you uh so you guys can tell what all actions can be performed in DB generally in a database in SQL database what all actions can be performed?
Create update
create find update Delet also can be happen. Same thing will happen in KV also because KV is also a database. Okay. So whatever if we create if we are creating a new customer create will happen in KV. If you're trying to update anything it will also update in KV. If you're trying to delete it that will also will happen in KV. So if we come to just perspective if we enable KV for a particular merchant so everything will happen in KV first and what all creates or updates or anything that happens it will immediately fall back to RD DB so that that only if you're opening your MySQL if you're opening your TX and DL you can find datas right but it will come to KV only then it is immediately falling back to the R DV okay but K is like as I told it's like a temporary database right so how it flushes means KV will have datas only for 12 hours so it will have all the datas for 12 hours and everything it will flush out to RDB within seconds but everything uh the datas in KV will be getting expired in 12 hours. So every 12 hours the datas in KV will get expired but it will uh for every second it will flush out to our DB so that we can see okay so that is how generally KV works. So we have uh four service configurations like That's how we used to enable KV. First is you might have known of KVC merchant cut over right.
So KVC merchant cut over is like the merchants which we want to enable KV for that merchants. And the next thing is like KVC enabled tables. So we have so much tables in our DB right. So for we have around uh if you can see in your MySQL we have around 40 to 50 tables in that 40 30 to 50 tables. If we want to enable these particular tables only for KV, if I wanted to pass these datas first to KV and then only to SQL, we'll enable all these tables first. So for this merchant example, Azer test in Azer test, I want TX in detail, order metadata, order metadata, V2 only these tables I wanted to uh go through KV. So for this only we use this cut over KVC enabled tables. Okay. And One more thing is like KV hard killing merchants. Have you heard of hard killing merchants?
Heart killing merchants. It's like so if we enable a merchant for KV hard killing means it will not enter into KV itself. Even though if merchant is enabled for KV if you if you want to find any any data if you wanted to find uh like for TX and details if if I want to check the pending status. If I wanted to check the status of that order id means it will directly search in SQL only. So if the hard killing is enabled everything you wanted to find it will not go to KV itself. It will go to SQL only. But if we enable this hard killing means first it will go to KV and search for that particular data and then it will fall back to SQL. It will search in both KV and SQL. Okay. So how can you check whe Whether it is like if this data is coming to KV or if it is coming to SQLs. So generally whatever you do even if you're doing a order create even if you're doing a create customer transaction anything if it is KV enabled or KV disabled the flow should work properly and one more thing is like so how you can find it's like we have four uh uh log types first it's like model source. So source is what it decides whether if you're doing an uh and one more thing is like action. Action is what this these things create, update, find, delete. These are the four options it supports in any database. These are the four uh actions that it supports. So whatever you do, even if you're creating anything or if you're ing, finding, deleting the source should be if if the merchant is enabled for KV, the source will be like KV or if you're disabling the merchant from KV and it is flowing through SQL means it will be like SQL. Sometimes if KV is enabled for one instance for uh some some scenarios what will happen is like you have enabled one merchant in KV you did a create and after some time you have disabled that merchant from KV and And if you wanted to update it, it will happen in SQL only. So at that time if you wanted to find the order id whether uh I have created an order and I have updated the amount but I have to check whether uh where it is I want to find it. So from where it will come so that time we have an option called KV and SQL. So these are the three types of source you can find in your database itself. Even in Kibbana you can find. So in Whatever actions you do, you can see the source and action for create whether it is coming from KV or if it is coming from SQL or it is coming from both KV and SQL. For KV and SQL how it finds like if we have two datas in KV and SQL, it searches the data from KV, it searches the data from SQL and it finds both the datas and gives us. So this is how generally the database works. And model is like you can you may find uh parameter called model. Model is the table name. You have heard of process tracker TX in detail order metadata v2 right. So for example all the table names will come under model. So the action in this table you have made is come through this source that is KSQL KSQL. So this is how you guys have to test. So whatever you test like if you're creating an order creating a customer or you're initiating a transaction or you are performing a DOT transaction or you a any transactions you guys have to check this main thing. If you if you are KV enabled everything should go every uh the table names I have given you three service configs right one is uh KVC merchant cut over KVC enabled tables these are the two main cutovers so in these both if the table is present and if the merchant is enabled these three things you have to mainly check in whatever you perform testing you guys have to verify this and verify the source should be every 10 k it should not be SQL if these both are enabled if once if the test is disabled for example if aert test is uh enabled in merchant cut over and the table like tx and dtape is not enabled in KBC enabled tables means it can be SQL because the table is not enabled in KV so it can go to SQL only but process tracker is enabled in KVC enabled tables so process tracker will take KV path only
so by default it take all the tables it will enable that that's a service config right so if you give false it will go everything it will take DV path only SQL path only so that's why we have to enable KV for that particular merchant and we have to enable the table also okay And uh we have another uh uh another ENV also called uh this reaching enabled. So this reaching enabled is also one service config. It is like so if you're u creating something in KV okay and after some time that means today you're creating a customer okay and you didn't perform anything. Tomorrow you're doing a wallet transaction. What will happen tomorrow? The data will be flushed out to DB, right? After 12 hours, now you're going to update something, you're doing a wallet transaction. So definitely the update will happen in TX in DT, right? So if you're doing an update and if you enable this is reaching enabled means whatever you perform like even if you're performing update or if you're performing a direct means that will happen in KV only. So that this it's like it will recach the things which you did in KV but the created data will not be in KV but the update that you're doing after 12 hours will be updated in KV only okay so this is one another one so is reaching enabled or not and u hard kill tables I told you right uh one more thing is KV is
K and cache both are same it's different
it's different KV is like a radius it's like a storage one cash we have in just pay uh uh point of view cash we have another uh kind of thing I'm not sure of your order status cache
because that flow is different
yeah it's like a separate D and K hardill tables also is there KV hard kill merchants also is there so that If you have disabled it, it will search from KV first. If it finds nothing, if it is any no data is there in KV, it will fall back to SQL. So similarly, how you can you guys can think it's like we have two database separate databases. So first it will search from KV and if if it didn't find data, it will fall back to SQL. If it finds data, it will take it from there. And for even for sandbox and production, the exp eration from KV is like 12 hours but the uh draining point of view is like within every second it used to drain from KV whatever data every data will come to the MySQL
and you can log you'll see that drainer locks right
it'll come so next one is like oiler drainer drainer is there so drainer is like uh once we do action in KV it should give to our DP right that's what the draining process is so we have a se separate uh service is called oiler drainer itself. So at the time itself within 12 hours we can't see that these uh datas are coming from SQL or not because entire uh flushing out will happen after 12 hours only right but every time the will happen to DV. So how you can check finally it is like from today I have created an order. So in it will be in KV only for valas tomorrow I wanted to verify if my order order id have come from KV to DB or not entirely. It is that uh data is not there in KV itself. It should be entirely SQL. That's that's how after 12 hours we'll get a lock on oiler trainer. In that how you can find it's like you will have a primary ID right in if you go to order metadata or order reference table you will have uh have ID in the first one right. So with that you can check in the oiler drainer logs that these ids this primary ID this secondary ID have got drained to SQL. We'll get a locks in Kibbana itself.
We'll have the primary uh ID of
like the what and all you have did like you can search oiler uh drainer and and what you wanted to know the order ID or uh something you can if you search like that you can check you will get the oiler drainer only if it is graved entirely to SQL. So like this you can check like whatever like you guys have to test first these three things you have to check before that in these four things you guys have to uh make sure like your uh merchant ID is enabled for KV or disabled and the tables which you guys wanted to do and we have two set of tables one is like in service configuration it's in service configuration we uh used to do uh changes right service configuration is also a table but we how do we uh update it? We have a dashboard right. So service configuration and what are the things that we do in the dashboards those are separate tables and we have separate tables like we how we internally hit the APIs and we make changes like orders transactions everything. So KV one more thing is like KV only supports hes. So in initially you guys have found issues when when we were In HS migration when we have enabled u merchant ids for PS KV will be breaking if the merchant ID is enabled for KBC merchant cut over that time it was breaking because KV entirely supports only HS okay and um one more thing is like uh what I was telling beforeh
service uh two tables it was there so the dash Dashboard tables will not come under KV only the tables which we hit internally that is like order TX and details which you can see uh in your MySQL only will support KV. So for other so for other tables like uh dashboard tables we uh that's what another like uh KV itself we have one one more thing called IMC. So IMC is called as in-memory cache. Okay. So inmemory cache also is the same process but we won't have uh service configurations. If we wanted to enable IMC or anything it will come under EMVs only. We'll be enabling EMV sing for that particular uh services or something and we have IMC enabled tables. IMC we don't have motion cut over we have IMC enabled tables and it is like repoise. So what IMC is like um for example IMC is like it is like temporary memory. where it will be uh storing the datas in its pod for example uh if we have RAM right so in RAM it will have a particular data for mainly why IMC they have decided it's like every time we have so much lookups into the tables we have so much lookups into the radius one every time if we if you wanted to if you're doing a update or uh create in a service configuration we have service configuration right sandbox service configuration. So many people used to update it. Many people used to create it. So every time it is going to redis and checking like if some create has happened or not or if someone have updated or not. Even if you're updating this KVC version cut over this is a service config right if you're updating it again it will go to the ret and check if any update is happening or not. So there are so much calls to the ret. We have so many service configurations right? So there are so many calls going to the ret. So the So due to this and uh and it is there's so much calls to the radius and there are so much calls to the SQL also. So to control this they have created IMC. So we don't want to go to the radius or SQL itself. If we enable IMC we have a particular storage called the pod memory. It is like in RAM we have a small memory right. So first we'll have a pod memory. First it will look up the latest changes for about five or 10 5 to 10 minutes it will store here in the pod memory. So if you if if for the last 1 minute if I change any if I update anything in KVC merchant cut over you don't want to go to the radius itself you can directly take from the pod memory itself. So the lookups can be very decreased if we enable IMC if we are updating anything for the last 5 minutes we have kept the TTL as 5 minutes. So for the latest 5 minutes what all updates you have done we no need to call we no need to look up for the radius itself we can take from the p memory itself for the last five minutes what all updates will happen it will be there in the part memory so that's why IMC have uh they have designed it so one more thing like how uh IMC works it's like if you're creating a new service config example uh test service config means You have created the service config. First this this it will go to the redisk only. It will go to the redisk and it will get stored like one new service config is get got created. Okay. And one person is like it's now it's similar is uh what editing it like updating something in this uh service config. So what will happen is like the updation also will come to red. this but radius in internally IMC is like very huge way they'll have so much streams like 20 streams they'll have okay in 20 streams they'll store like uh updation 11 one1 updation for 10 minutes they'll store they'll have 20 streams they uh they'll tell so in this red we don't need to look what update is happened or not for that it will happen a snake these streams only we have one more uh function called lookups. We don't need to know about lookups. It is like a very vast one. So uh so for uh each things we don't need to go into it. So IMC will have will take it from the latest pod memory and it will give us for example how I told like source will be KVSQL and KVSQL. Similarly the source will be like IMC. This way you can check if it is coming from IMC or not. Now can you guys
cut for this?
No cuts env.
So if you enable the IMC envir
that's what I told right IMC is for these set of tables dashboard related tables
only for dashboard
dashboard related tables like service configuration also is a table but how we are updating it. through a dashboard only you know and uh we have uh this one also saved payment method that is not that is not also uh KV table that is also an uh dashboard table only there it will just uh because save payment method it is also from front end they are updating it and dashboard people also will be updating it
it will not get it will not get come under KV itself so all the service configuration or save payment method only we from KB side we'll only do read functions we'll just read it we won't do update or create because that is directly done from their side payment method service configuration and all so these all tables will only will come under IMC KV the the normal tables which we regularly use any doubts And when hard killing earlier
uh hard killing is like if we enable hard killing if if we if we wanted to if you enable KV hard killing merchants means we are if even if the merchant is enabled for KV it if we are finding anything it will directly go to SQL everything okay uh uh uh I told you right every millisecond like every second it will to DB. So if you want to find anything or if you want to update anything, it will directly do everything in SQL only.
No, it won't it will not ever check KV.
Okay. Check.
Yeah, it will entirely take DB only. The find also the find read everything will happens in DB only through DV.
Similar to disabling KV.
No, no, the updation everything will happen in KV also. But what we get is like it it will be from SQL.
We'll get data from both KV and SQL.
It won't be stored in KV. But we'll get
yeah the read and all read function and uh write functions all will happen in SQL. But if we disable it, it will check in KV first and if it if it finds anything that the data which you want, it will give to you. If if it is if there is nothing, it will fall back to SQL.
See if a merchant is enabled for KVC enabled merchant. Disabled for KVC enabled merchant and they will also disabled but enabled for K disable for KV hot merch also then will not ever work.
No,
this this comes only if these two are uh enabled K because you're not enabling the mer issue in sandbox. So we used to do some DB update.
So she did the DB update in DB it is showing as um pending but in auto status it is still showing as charged
and we try to it is from K and we try to disable the both cuts but still it is showing as K
because K hard killing it it's like whatever if there are there is any delay in training also it will directly take from the SQL only that's why we need we use this uh KB hard kill merch and tables that
yeah so usually we used to disable it. So whatever the merchants we are enabling for KV we used to disable it so that every time it checks from KV if nothing is there it will fall back to SQL.
Yeah.
Wait a second is enabled
uh what happens is uh we a lookup happens in K.
No
not at all.
Yeah it Uh yeah from last how much days this is what I heard like if it is disabled even the lookups happens in SQL only ifable
oh sorry if it is enabled if it is disabled first it will search in KV and if it is nothing is there only it will go to SQL
there are not
yeah no not having KV instead not having KV means it will entirely everything will happen in only know I'm telling if it is disabled it will search in KV first.
Okay.
Ah
if you find data it will be displayed if you find if you didn't find anything it will fall back to SQL
and can you give an example of KV and SQL when it will be the source will be KQL?
Uh KVNS SQL is like KVNS SQL will happen only for find find and uh update because this is where this reaching uh will come. If we are enabling this reaching enabled what I told like first if it is KV and after 12 hours it is in DB. If you wanted to update anything it will happen in KV only. So it is reaching some datas for the further use. So only if it is disabled is reaching is disabled only. this function will happen. KV and SQL will happen because it tries to find from both KV and SQL because if reaching is enabled means if it won't find in KV itself because every I mean sorry it won't find in SQL itself. Every create and update will happen in KV itself. So KV and SQL happens for find function and update function and this should be disabled for this one. Okay.
So every time for some uh scenarios it will get stored in KV and it will get stored in SQL also. But what we'll take is like for that particular table we used to take datas from both KV and SQL. Sometimes datas will be there only in KV and sometimes it will be there in only in SQL. But if for some tables I have seen the situations in safe payment method itself for uh some things that is like after uh 12 hours or after 12 hours it gets entirely pushed to DB right at that time even for similar datas were found in both KV and SQL that at that time what it does is like it takes KV value all KV value it takes SQL value and and uh gives in this format like it will take the all the similar values in uh both the tables and if you have any uh other non-similar things also it will come in this format and
in KV what kind of errors will they get
KV mainly we have to check the source it should it should go through KV only and uh all the flows should be working as expected that is what the first thing and we'll have errors at some point of time for uh some scenarios we'll have like uh some secondary key is missing or uh primary key is missing. Why why happened is like in in our first testing even Paul knows I think for uh submit OTP the secondary key was missing
because there were usage of two tables at the same time. I am not remembering the tables at the at that time two tables they were using at the same time. So the it was failing to take uh key from the other table also. So there should not be any errors called this key is missing then uh this is failing through it anyway you will get uh it will it is due to KV only the log lines are mentioned and one more thing if if the source is filtered also because for all the uh repos it is filtered we have another log line called uh processed through KV you might have know this processed through KV so This value should be true
with this also you can confirm this like it is going through KV
and find one with error it's a valid error or
find one with error something before in KV we used to get like find one with error in locks
so find one on what we were getting is like uh find we used to search for many keys right find was happening like con constantly 2 KV. So we had a lot of lots and lots of logs. So first we used to disable it. So that's why then they have first we got that error that's a error only. Then we made as like find all. So whatever find happens and you will have an envo find all should be enabled or not like whit listing or something that if you enable you can easily search like if the find is happening in KV or SQL but it will have like n number of logs in Kibbana because every time we used to search anything in uh anything like if you wanted to search any order ID also in the DB mainly and one more error is like you should not get any DB error DB error or uh radius error.
Uh Josha uh does psql also get involved in KV like schedule PT sync one
that is also a table right
that that is dashboard that will come under IMC for IMC is just in work in progress we have enabled only for service configuration no SQL I no
KV yeah
okay
and uh one more thing like last time like when we were doing right like even when the KV cut is and all it is is enabled when we do a transaction from our end would be like pending or charged but we don't see locks in SQL so that is like KV issues something like drainer is not working and all right so
that is because uh drainer gets stopped that time only if we do a transaction also if you if you try finding in SQL you won't get any logs you'll be getting as no records found that is because all of a sudden the drainer will get stopped we have two uh things in drainer like uh drainer stop and uh coarse drain. These both are uh in HS actually. Drainer stop is like we have not enabled it. Now drainer stop is like somehow like uh Malav used to tell us like if we find any error in KV the drainer will stop immediately. So this is what this uh this is an ENV actually trainer stop. So if you able drainer stop whatever if it is a small error also in HS like in KV uh KV HS KV the drainer will stop immediately this is an EV actually only if we enable it that happens but sometimes the drainer gets stopped just like that because of if it can't uh take up the load it used to stop and one more is like force drain force drain it's like this one we can do like anytime if you want to enable like flush out everything from KV to DB immediately means we use this for drain. These both are not in our hands. SR guys will do that.
So do we see this thing in log?
No, you want to
we can see that source and other things in logs right?
This these things everything you can see in logs. Um I was telling about this drainer stop and force drain.
Okay. If it is stopped, we cannot see those things in block.
Yeah, you can you cannot see in SQL itself. So in even in sandbox or in production, every data if it comes from if it comes to KV, it will drain seconds to DB also. If you can't find your uh any details like order ID or anything in DB, that means drainer got stopped. Not every time. Any other questions?
And even if it drains out to main SQL table, so will be there in the this KV table also for 12 hours, right?
Yes. Yes.
It will get removed only after 12 hours. Even in production and sandbox, it is the same. uh time period only.
Uh Josha when you were testing you used to say right I have to check this tomorrow in the locks like needs 12 hours like what is that you will be checking for
that's what the drainer is so oil drainer will tell that so if I'm creating an order okay I have created an order today that is in KV now after 12 hours if I'm trying to find it I'm doing get get order status okay get order status is a finding uh action only right after 12 hours if I'm doing a get order status means in uh in logs we can see the source will be like SQL so still in 12 hours it will be like KV only I wanted to check mainly whether it is draining everything that is from KV everything is flushing out or not so with till 12 hours even though it is draining into SQL the it the all the details all the datas it will take from the KV only till 12 hours so that you can find for 12 hours you can check like it will be in KV only source will be like in KV only but the D but the datas will be there in DB also that's what you can see in your MySQL sir
okay
so after that all if we enable the reaching then source will be KB and SQL right
it would mean SQL reaching is like you can update anything but that will that updation will happen in KV the updation is see the order ID you have created right
created in KV then after that after 12 hours it went to SQL but this reaching is enabled okay after 12 hours you can't enable the reaching what will it reach
oh
you have to enable it first itself it will reach
after 12 hours then it will be SQL only everything will be in SQL If you are creating created in KV with reaching enabled after 12 hours it will go to SQL
then if you're trying to update it you're doing an update order that update will happen in KV but the create happened right yesterday that will be in SQL only no if you're trying to find it you're just updating here if you're doing a get or a status it will come in SQL if you're trying to update It will be
in KV.
It will be in KV. It is happening
bro. Find find create update. Find find what example get order status. It doesn't do anything, right? You're not updating anything. You're not creating anything. It just takes the data and gives to you. It's just fetching of data. Update is like already you have created any instance and you're trying to update it. You're updating the amount or something. So already you have data of order ABC. In order ABC you have amount as 1. In this order we see I'm updating the amount as 1 to 10. This is what this update will happen. But already we'll have a date of create right update.
Update. Yeah update will be happening in KV only because you have enabled the reaching. This is like some data you wanted to be in KV. If you think like that they'll be enabling the reaching but if you're finding you're doing a d status for these things it will come KV and SQL only it will take from KV
but the created you have did this yesterday itself
that will be in SQL only you can just check like you can give your order iding is config or env is itable for anything I think so. We have to check in production. Production. I'm not sure.
Any doubts. I do. You can search if you're uh any order ID or you can use session ID also and you can search like what action did you do create update or or just you can search as action and source your order ID or session ID? Order ID or if you session ID, action and source process to come.
It will come for everything. Yeah.
In before we get uh processed_2 KV before that it will be like value it should be true.
So what we call find like K and In that case it sources KV and SQL in that case process to KV will be false or true.
It will be true
if it is if you're doing uh for for find you're telling if the merch it checks with this cut over then whether that time it is enabled or not. So whatever testing you do you can you guys can check this also. Don't know what.
Thank you guys.
